# 5. デプロイ手順と検証

このセクションでは、このデモを自身の Azure サブスクリプションに
デプロイし、サービスが正しく動作しているか確認します。
**Azure Developer CLI (`azd`)** を使用してインフラの構築とアプリの
デプロイを自動化します。

## デプロイ手順

1. **リポジトリのクローン**（未実施の場合）:

   ```bash
   git clone <リポジトリ URL>
   cd cosmos-cf-demo
   ```

2. **Azure へのサインインと初期化**:

   ```bash
   az login
   azd login
   azd init --subscription <サブスクリプション ID>
   ```

   実行中にリソースグループの選択または作成を求められます。デフォルトでは
   `rg-cosmos-cf-demo` が作成されます。

3. **プロビジョニングとデプロイ**:

   ```bash
   azd up
   ```

   このコマンドは次の 2 つの処理を行います:

   * **プロビジョニング** – Bicep テンプレートを実行して Cosmos DB アカウント、
     データベースとコンテナ、Container Registry、Container Apps 環境などを作成します。
   * **デプロイ** – `generator`、`summariser`、`visualizer` の Docker
     イメージをビルドして ACR へプッシュし、各 Container App としてデプロイします。

   処理には数分かかります。完了すると各サービスのエンドポイント URL が表示されます。

4. **ビジュアライザーにアクセス**:

   出力された `visualizer` アプリの URL をブラウザで開くと、5 つのセンサーの
   グラフが 2 列のレイアウトで表示されます。新しい集約データが到着すると
   該当センサーのグラフのみが自動更新され、赤い丸印が表示されます。

5. **ログの監視**（任意）:

   generator や summariser のログを確認したい場合は、`az containerapp logs`
   コマンドを使用します。例:

   ```bash
   az containerapp logs --resource-group <リソースグループ> --name <アプリ名>
   ```

   `<アプリ名>` には `cosmoscf-demo-generator` のような名前を指定します。

6. **環境の詳細確認**（任意）:

   デプロイ後は CLI で作成されたリソースを調査してみると理解が深まります。例えば、リソースグループ内の全リソースを一覧するには以下のコマンドを使用します。

   ```bash
   az resource list --resource-group <リソースグループ> -o table
   ```

   また、各 Container App の詳細を表示するには次のように実行します。

   ```bash
   az containerapp show --resource-group <リソースグループ> --name <アプリ名>
   ```

   このコマンドは FQDN、割り当てられたマネージド ID、スケーリング構成、環境変数などを返します。`COSMOSDB_ENDPOINT` などが正しく設定されているか確認できます。実行中のコンテナにシェルで入ってネットワークや環境変数を調べるには以下を使います。

   ```bash
   az containerapp exec --resource-group <リソースグループ> --name <アプリ名> --command sh
   ```

   これはデバッグやトラブルシューティングに便利です。

## デプロイ後の確認項目

デプロイ完了後、次の点を確認してください。

* **Cosmos DB** アカウントに `sensors` データベースと
  `readings`、`summaries`、`leases` の各コンテナが存在するか。
  Azure ポータルの Data Explorer からアイテムを確認できます。
* **generator** のログに、各センサーがランダムな間隔でデータを
  書き込んでいるメッセージが表示されているか。
* **summariser** のログに、新しい読み取りがあるたびにサマリが
  出力されているか。
* **visualizer** のページにグラフが表示され、データ更新時に
  自動更新されているか。

問題がある場合は、ログを確認し、`azure.yaml` の環境変数が正しく設定されているか
確認してください。

## パラメータとカスタマイズ

上記の手順はデモを既定値でデプロイしますが、アプリケーションやインフラは柔軟に調整できます。要件に合わせて以下の設定を検討してください。

* **Cosmos DB のスループット** – `infra/main.bicep` では `sensors` データベースと各コンテナを 4000 RU/s のオートスケールで作成しています。負荷に応じて値を増減したり、手動スループットモードに変更することもできます。パーティションあたり最低 10 RU/s の制限とコストを考慮してください。
* **リージョン選択** – `azd up` の実行時にリージョンを選択します。ユーザーに近いリージョンを選ぶことでレイテンシを減らせます。セカンダリリージョンを追加してフェイルオーバー構成を組むことも可能です。
* **コンテナのスケーリング** – Bicep テンプレートでは各 Container App のレプリカ数を 1 に設定しています。大規模なワークロードでは `scale` プロパティを変更して CPU やキュー長に基づくオートスケールを有効化できます。
* **環境変数** – `azure.yaml` では Bicep の出力を環境変数にマッピングしています。独自の設定（アラートの閾値やサンプリング間隔など）を追加し、Python コードから参照することもできます。`azure.yaml` を変更した後は `azd deploy` でデプロイを更新してください。

`azd up` では `--location` や `--subscription` のフラグを指定することで、デフォルト以外のリージョンやサブスクリプションにデプロイできます。詳しくは [Azure Developer CLI のドキュメント](https://learn.microsoft.com/azure/developer/azure-developer-cli/reference) を参照してください。

## 継続的デプロイと CI/CD 統合

チーム開発では、デプロイ作業を手動ではなくパイプラインに組み込むと効率的です。`azd` には GitHub Actions や Azure DevOps 用のワークフローを生成するコマンドがあります。

```bash
azd pipeline config
```

このコマンドを実行すると `.github/workflows` または Azure DevOps パイプライン用の YAML が生成され、プルリクエストで `azd up`、メインブランチへの push で `azd deploy` を自動実行できます。Azure サービスプリンシパルの資格情報 (`AZURE_CREDENTIALS`) をリポジトリのシークレットとして登録し、パイプラインが Azure に認証できるようにします。

複数環境へのデプロイやリージョンごとのデプロイを行う場合は、ジョブを分割して `build`、`infra`、`deploy` など段階的な構成にすることもできます。

## ローカル実行とパッケージング

本番環境は Azure Container Apps ですが、開発中にローカルで動作確認することも可能です。`azd package` を実行するとイメージがビルドされ、`.azd/docker-compose.yaml` などのファイルが生成されます。

```bash
azd package
docker compose -f .azd/docker-compose.yaml up
```

これにより Docker 環境で各コンテナを起動できます。また、**Cosmos DB Emulator** を使用してクラウドに接続せずにテストすることもできます。その場合は `COSMOSDB_ENDPOINT` をエミュレーターの URL に設定し、プライマリキーを環境変数にセットしてください。

## よくある問題のトラブルシューティング

デプロイが失敗したりアプリが期待通りに動作しない場合は、次の点を確認してください。

* **Bicep エラー** – `azd up` 中にテンプレートの構文エラーや無効なリソース名があるとデプロイが停止します。`bicep build <file>` でローカルコンパイルして JSON を確認し、`BCP` コードをもとに原因を特定します。
* **コンテナビルド失敗** – `azd deploy` で依存ライブラリが見つからない、ネットワークタイムアウトが発生するといったエラーが出た場合は、ローカルで `docker build` を試して詳細ログを確認します。
* **コンテナ起動エラー** – `az containerapp logs --name <アプリ名> --follow` でログをストリームし、Python のトレースバックなどの例外を確認します。環境変数が不足している場合は `azure.yaml` の出力と一致しているかをチェックします。
* **接続性の問題** – アプリが Cosmos DB に接続できない場合、接続文字列や AAD 資格情報が正しいか、ファイアウォールで Container Apps の出力 IP が許可されているかを確認します。`az containerapp exec` でシェルに入り、`curl` で Cosmos エンドポイントへの疎通を確認すると役立ちます。

継続的なデプロイの構築、ローカル開発環境の活用、そして体系的なトラブルシューティング手法により、イベント駆動アプリケーションの運用に備えることができます。

## 高度な Bicep テクニックとパラメータ化

このラボのテンプレートは基本構成ですが、より大規模なプロジェクトでは柔軟性が求められます。以下の拡張が役立ちます。

* **再利用可能なモジュール** – テンプレートを Cosmos DB や ACR、Container Apps ごとに分割し、パラメータとデフォルト値を定義します。Agentic Shop のワークショップには `database.bicep`・`ai.bicep`・`container.bicep` などのモジュール例が含まれています【716571452689310†L61-L96】。
* **条件リソース・ループ** – `if` キーワードで必要なときだけリソースを展開し、`for` ループで複数のコンテナやアプリを生成します。マルチリージョン展開や多数のセンサーに対応する際に便利です。
* **命名規約とタグ** – リソース名のプレフィックス／サフィックスを変数で定義し、`tags` に `Environment=Prod` などのタグを設定してガバナンスやコスト管理を容易にします。
* **ロール割り当て** – 本デモのようにサマライザーやビジュアライザーにロールを付与するほか、`Cosmos DB Account Reader` やカスタムロールを利用して権限を細かく調整します。`guid()` を使えば決定論的な名前が生成できます。
* **出力の活用** – FQDN やリビジョン ID、キーなどを `output` で公開し、`azure.yaml` やパイプラインから参照できます。

## 継続的デプロイとの連携

`azd deploy` は手元で便利に使えますが、CI/CD パイプラインに組み込むことで一貫したデプロイを実現できます。一般的な流れは次の通りです。

1. `docker build` または `az acr build` でイメージをビルドし、ACR にプッシュします。
2. `az deployment sub validate` で Bicep テンプレートの静的検証を行い、問題点を早期に発見します。
3. `azd provision` あるいは `az deployment group create` でインフラを展開し、プロダクション環境ではデプロイスコープにロックを設定します。
4. `azd deploy` や `az containerapp update` を用いてアプリケーションを更新します。環境変数やパラメータファイルにより環境差分を吸収します。
5. デプロイ直後にビジュアライザーのエンドポイントでスモークテストを実施し、エンドツーエンドの動作を確認します。

Agentic Shop の `templates` ディレクトリには、azd と GitHub Actions を組み合わせたパイプライン YAML が含まれており、参考になるでしょう。

## 高度なローカル開発のヒント

開発効率を高めるために、以下のテクニックを活用できます。

* **ホットリロード** – Flask を `--reload` で起動するか、FastAPI を使ってコード変更時に自動再起動できるようにします。反復作業がスピードアップします。
* **Python 仮想環境** – `venv` や `conda` で依存関係を隔離し、コンテナ内環境と整合を取ります。
* **対話型デバッグ** – `az containerapp exec` で実行中のコンテナに接続し、VS Code Remote – Containers などでブレークポイントを設定してデバッグできます。

これらの高度な設定とテクニックを取り入れることで、素早いフィードバックサイクルを維持しながら、生産性の高い開発と運用を実現できます。
