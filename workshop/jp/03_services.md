# 3. 使用している Azure サービス

このデモでは、スケーラブルでサーバーレスなパイプラインを構築するためにいくつかの Azure サービスを活用しています。
それぞれの役割を理解することで、データの取り込み、処理、保存、表示の全体像が見えてきます。

## Azure Cosmos DB for NoSQL

Cosmos DB はグローバルに分散されたマルチモデルデータベースサービスで、スキーマフリーの JSON ドキュメントと SQL ライクなクエリを提供します。
このラボでは `sensors` データベースに以下の 3 つのコンテナを作成します:

* `readings` – センサーの生データを保存します。パーティションキーは `/sensor_id` です。
* `summaries` – サマライザーが計算した最大値・最小値・平均値を格納します。同じく `/sensor_id` でパーティション分割します。
* `leases` – Change Feed プロセッサが進捗を管理するためのトークンを保持します。

Cosmos DB の魅力は柔軟なドキュメントモデルだけでなく、**グローバル分散** と調整可能な一貫性モデルにあります。
数クリックで任意の Azure リージョンにデータベースを複製でき、マルチリージョン書き込みを有効にすると低遅延かつ高可用な構成になります。
本デモでは単一リージョン構成ですが、フェイルオーバー用にセカンダリリージョンを追加することも可能です。
一貫性レベル（例: *Session*、*Strong*、*Eventual*）はレイテンシと鮮度のトレードオフを制御し、変更フィードも選択した一貫性レベルに従います。

Cosmos DB では全てのプロパティがデフォルトで自動索引付けされます。
イベント処理ワークロードでは、インデックス ポリシーをカスタマイズして書き込みコストを削減することもできます。
例えば、クエリしない大きなネストプロパティや文字列フィールドを索引から除外することで RU 消費を抑えます。
パーティション設計も重要です。
このデモでは `/sensor_id` を使用して各センサーのデータを同じ論理パーティションに格納し、Change Feed 処理を効率化しています。
代わりに日付などの時間ベースでパーティション分割すると、1 つのセンサーのデータが複数のパーティションにまたがりクエリが複雑になる場合があります。
要件に応じて慎重に選択してください。

## Azure Container Apps

Container Apps はサーバーレスなコンテナプラットフォームで、マイクロサービスやイベント駆動アプリをインフラ管理なしで実行できます。
HTTP リクエストや CPU/メモリ、KEDA トリガーに基づいて自動スケールされます。
また各コンテナは [**マネージド ID**](https://learn.microsoft.com/azure/active-directory/managed-identities-azure-resources/overview) を使用して安全に Cosmos DB などへアクセスできます。

このデモでは、3 つのコンポーネント (generator、summariser、visualizer) をそれぞれ独立した Container Apps としてデプロイします。`azd` のデプロイ手順に従えば、Bicep テンプレートが自動的にマネージド ID の作成と権限付与を行います。

Container Apps は単なるコンテナ実行環境にとどまらず、**オートスケーリング** や [KEDA](https://keda.sh/) によるイベントトリガーなど多彩な機能を提供します。
本ラボではサマライザーは固定レプリカ数で動作しますが、CPU 使用率や HTTP キュー長、変更フィードのバッチ数などに基づいて自動的にスケールアウト・スケールインさせることもできます。
各スケール操作はダウンタイムなしに新しいインスタンスを追加・削除し、リソース消費に応じてコストを最適化します。
また Container Apps には **リビジョン** の概念があり、デプロイごとに新しいリビジョンが作成されます。
カナリアリリースのためにトラフィックを複数リビジョンへ分割したり、迅速にロールバックしたりすることができます。
ログやメトリックは Azure Monitor と Application Insights に統合されているため、アプリの状態を詳細に監視できます。

マネージド ID も重要です。
環境変数にシークレットを配置する代わりに、各 Container App にユーザー割り当て ID を付与し、Cosmos DB へのデータプレーン ロールを Azure RBAC で設定しています。
アプリケーションコードでは `DefaultAzureCredential` を使用してトークンを取得し、秘密情報をコードやログに残さず安全に認証できます。
これは最小権限の原則に則ったベストプラクティスです。

### 基本機能を超えて

Container Apps には、ラボでは使用していない高度な機能が多数あります。

* **Dapr 連携** – Dapr (Distributed Application Runtime) を有効にすると、サービス呼び出し、ステート管理、Pub/Sub などの機能を標準化された API で利用できます。
  サービスディスカバリを意識せずにマイクロサービス間通信が可能になります。
* **KEDA トリガー** – CPU や HTTP 以外にも、Kafka トピックの長さや Service Bus キューのメッセージ数、Event Hubs パーティションのイベント数などに基づいて自動スケールできます。
  Bicep や YAML の `scale` セクションで KEDA スケーラを定義します。
* **カスタムドメインと TLS 証明書** – アプリに独自ドメインを割り当て、TLS 証明書をアップロードできます。
  ユーザにブランド化された URL を提供したい商用環境で有用です。
* **リビジョン管理** – デプロイのたびに新しい **リビジョン** が生成されます。
  リビジョンモードを **multiple** にするとトラフィックを複数リビジョンに分割でき、**single** にすると最新リビジョンのみを有効にします。
  `az containerapp revision list` でリビジョン一覧を取得し、`az containerapp ingress traffic set` でトラフィックの割当てを変更できます。
* **シークレット管理** – コンテナアプリ環境に定義したシークレットをアプリケーションから参照できます。
  Bicep の出力に含まれない API キーなどの機密情報は Azure Key Vault と統合して注入することもできます。


Azure Container Registry にはイメージ格納以外にも次のような高度な機能があります。

* **ACR Tasks** – リポジトリに変更がプッシュされた際に自動的にイメージをビルド・プッシュするタスクを定義できます。
  スケジュール実行や複数アーキテクチャ対応、ベースイメージの更新追従に利用できます。
* **コンテナイメージの脆弱性スキャン** – Microsoft Defender for Container Registries と連携し、イメージをプッシュした際に既知の脆弱性をスキャンします。
  Azure Security Center からレポート閲覧やアラート設定が可能です。
* **プライベートリンクとファイアウォール** – ACR にプライベートエンドポイントを設定し、仮想ネットワーク内からのみアクセスさせたり、IP アドレス範囲でアクセス制御ができます。
* **イメージのインポート** – `az acr import` コマンドで Docker Hub 等他レジストリからイメージを取り込み、外部依存を自レジストリに集約できます。


## Azure Container Registry (ACR)

サービスの Docker イメージは Azure Container Registry に保存します。
ACR はプライベートな Docker レジストリであり、Container Appsとの統合が容易です。
`azd` ワークフローでは、デプロイ時にイメージのビルドとプッシュが自動的に行われます。

ACR にはチーム開発で役立つ追加機能が多数あります。
例えば **ジオレプリケーション** を設定すると、一つのリージョンにプッシュしたイメージが他リージョンに自動的に複製され、リージョン間の転送コスト削減とデプロイ時間の短縮に繋がります。
また **保持ポリシー** を設定して古いイメージを自動で削除することでストレージ料金を抑制できます。
[Content Trust](https://learn.microsoft.com/azure/container-registry/container-registry-content-trust) を利用すればイメージに署名し、デプロイ時に整合性を検証することも可能です。
さらに、Azure RBAC の `AcrPull` や `AcrPush` ロールで権限を細かく制御できます。

## Bicep と Azure Developer CLI

インフラは **Bicep** という宣言的な構文で定義されています。
`main.bicep` テンプレートには必要なリソースと接続情報が記述されており、**Azure Developer CLI (azd)** はプロビジョニングとデプロイの全工程を管理してくれます。
テンプレートやパラメータを変更することで、自身の環境に合わせたカスタマイズが可能です。

Bicep は ARM テンプレートの機能を簡潔な構文で提供する言語で、モジュール化、ループ、条件分岐をネイティブにサポートします。
各リソースは一度宣言すれば再デプロイ時に状態を自動的に同期します。
本プロジェクトでは `main.bicep` で Cosmos DB アカウント、データベース・コンテナ、Container Apps 環境、マネージド ID とロール割り当てを定義し、個別のモジュールで各コンテナアプリを構築しています。
このモジュール化により再利用性と可読性が高まります。
Bicep の `output` に定義した値（Cosmos のエンドポイントやクライアント ID など）は `azure.yaml` で環境変数として利用されます。

Azure Developer CLI はインフラとアプリケーション デプロイをまとめて処理します。
`azd up` はサブスクリプションとリージョンの選択を行い、Bicep に基づいてリソースを作成し、アプリコードをビルドして ACR へプッシュし、Container Apps として展開します。
コードのみを変更した場合は `azd deploy` でイメージの再ビルドと更新のみを実行できます。
ラボが終了したら `azd down` でリソースグループごと削除し、不要な課金を防ぎましょう。

### Bicep と azd の深堀り

Bicep は ARM テンプレートを読みやすくするために設計されています。
以下の高度な機能を試してみると良いでしょう。

* **モジュールと再利用** – 大きなテンプレートは `module` キーワードで分割し、パラメータ経由で入力を渡せます。
  出力値は階層的に戻り、他のリソース定義に利用できます。
* **ループと条件式** – `for` 式で類似リソースをまとめて作成したり、`if` 式で条件付きリソースを追加できます。
  例えば、センサーのリストをループして各センサー用のコンテナを作成することも可能です。
* **セキュアパラメータ** – `secure` 型でパラメータを宣言すると値がログに出力されません。
  Key Vault 参照と組み合わせて、デプロイ時に秘密情報を取得できます。
* **ターゲットスコープ** – Bicep はリソースグループだけでなく、サブスクリプションや管理グループスコープにもデプロイできます。
  企業環境ではサブスクリプションレベルでポリシーやロール割り当てを一括適用する場面があります。

Azure Developer CLI (`azd`) は Bicep と Git を統合した意見的ワークフローを提供します。
次のような機能があります。

* **環境管理** – `azd env list`、`azd env new`、`azd env select`、`azd env delete` で複数の環境を切り替えられます。
  それぞれの環境は `.azure/{環境名}.env` に設定が保存されます。
* **パイプライン統合** – `azd pipeline config` を利用すると GitHub Actions や Azure DevOps 向けの CI/CD パイプラインを自動生成できます。
  シークレットをパイプラインに登録することで Azure 認証を行い、`azd up` や `azd deploy` を自動実行できます。
* **フック** – プロビジョニングやデプロイの前後に任意のスクリプトを実行する `preprovision`、`postprovision`、`predeploy`、`postdeploy` フックを設定できます。
  これによりデータベースの初期化やテスト実行、通知送信などを自動化できます。

### Cosmos DB のインデックス設計とクエリ最適化

Cosmos DB はデフォルトで全てのプロパティにインデックスを作成しますが、ワークロードに合わせてポリシーを調整することで RU 消費とストレージを最適化できます。

* **除外パスの設定** – クエリで使用しない大きなネストオブジェクトなどがある場合、`excludedPaths` に指定してインデックスから除外します。
  これにより、書き込み時の RU とインデックスのサイズを削減できます。
* **複合インデックス** – 複数列のフィルタやソートを行う場合は、`compositeIndexes` を定義してフルスキャンを回避します。
  例えば `sensor_id` と `timestamp` でソートする場合、両方を昇順・降順で指定します。
* **ユニークキーと空間インデックス** – センサーが位置情報を持つ場合は空間インデックスを有効にすると範囲検索が高速になります。
  また、`id` と `timestamp` の組み合わせでユニークキーを設定すると重複書き込みを防げます。
* **クロスパーティションクエリ** – パーティションキーを指定しないクエリは全パーティションをスキャンします。
  低 QPS の分析クエリであれば許容できますが、高頻度の場合は `WHERE` 句に `sensor_id` を含めるか SDK で `PartitionKey` を指定しましょう。
* **専用ゲートウェイの利用** – 読み取り負荷が高い場合、専用ゲートウェイを利用することでネットワーク帯域とパース負荷を分散できます。

### Container Apps の詳細機能

Azure Container Apps (ACA) は Kubernetes を抽象化したサーバーレス基盤で、多彩な拡張機能が用意されています。

* **Dapr 連携** – **Distributed Application Runtime (Dapr)** のサイドカーを有効にすると、サービス間通信や状態管理、秘密情報の取得をシンプルな API で実装できます。
  YAML でコンポーネントを定義し、アプリ側は HTTP/gRPC 経由で呼び出します。
* **KEDA によるスケーリング** – ACA の自動スケールは裏側で **KEDA** を利用しており、キュー長や CPU 使用率など様々なトリガーに応じてレプリカ数を調整できます。
  センサーの負荷が不均一な場合に役立ちます。
* **リビジョンとトラフィック分割** – デプロイごとに新しいリビジョンが作成され、リビジョン単位でトラフィックを何％割り当てるか設定できます。
  カナリアリリースやブルーグリーンデプロイに活用できます。
* **ネットワークとセキュリティ** – VNet 統合、HTTPS 強制、Key Vault からのシークレットマウント、マネージド ID の付与が可能です。
  秘密情報は環境変数ではなくシークレットとして登録し、アプリから参照しましょう。
* **Jobs と cron** – 最近追加された **Container Apps Jobs** を利用すると、定期的なバッチ処理や単発ジョブを簡単に実行できます。
  集計処理やデータクリーンアップをバッチジョブに移すこともできます。

### Azure Container Registry の高度な機能

ACR は単なるコンテナイメージの保存場所だけでなく、CI/CD やセキュリティ強化にも利用できる機能を備えています。

* **ACR Tasks** – ソースの変更やタイマーイベントをトリガーに、ACR 内部で Docker ビルドやマルチステップスクリプトを実行できます。
  ビルド環境をパイプラインから切り離し標準化できます。
* **イメージの脆弱性スキャン** – Microsoft Defender for Cloud と統合し、既知の脆弱性を検出します。
  ポリシーを設定して問題があるイメージのデプロイをブロックできます。
* **コンテントトラストと署名** – **Notary** を使ってイメージに署名し、デプロイ時に整合性を検証できます。
  署名されたイメージのみを Container Apps で受け入れるように設定することも可能です。
* **プライベートリンクとネットワーク制御** – Cosmos DB 同様、ACR もプライベートエンドポイントとファイアウォールルールをサポートします。
  特定の VNet からのみアクセス可能にすることでセキュリティを高められます。
* **イメージのインポートとジオレプリケーション** – Docker Hub などの外部レジストリからイメージを直接インポートしたり、リージョン間でレジストリを複製することでプル時間を短縮できます。

これらの機能を組み合わせることで、エンタープライズレベルのセキュアなコンテナサプライチェーンを構築できます。

## セキュリティ、コンプライアンス、可観測性

エンタープライズ用途では規制遵守やアクセス制御、運用監視が重要です。以下のポイントに注意してください。

* **暗号化 (保存時・転送時)** – Cosmos DB は既定で暗号化されており、Azure Key Vault で **カスタマー管理キー (CMK)** を指定することもできます。
  Container Apps はエンドポイントで TLS を終端でき、Dapr を利用するとサービス間の相互 TLS も可能です。
* **ネットワーク分離** – プライベートエンドポイント、IP ファイアウォールルール、VNet 統合を組み合わせることで、データベースやレジストリをインターネットから遮断できます。
  Container Apps 環境を VNet 内に配置し、Application Gateway や API Management 経由で公開するのも一案です。
* **ロールベースアクセス制御 (RBAC)** – 各コンポーネントに最小権限を付与します。
  例として、Visualizer には **Cosmos DB Data Reader**、Summariser には **Data Contributor** を割り当てます。
  監査ログは Azure Monitor で取得し、Log Analytics へ送信して分析できます。
* **可観測性** – Cosmos DB (メトリクス・ログ)、Container Apps (リビジョンログ)、ACR の診断設定を有効にし、Azure Monitor もしくはサードパーティへ送信します。
  RU 消費量の急増やコンテナの再起動ループ、イメージスキャン失敗などを検出するアラートを設定します。
  **Azure Monitor ワークブック** や **Grafana**、**OpenTelemetry** などで情報を集約できます。

## AI と高度なデータ機能の統合

このデモでは Cosmos DB の SQL API を使っていますが、マイクロソフトのデータプラットフォームには他にも魅力的な機能があります。

* **ベクトル検索** – Azure Cosmos DB for MongoDB vCore や Azure Cognitive Search ではベクトルインデックスをサポートしており、セマンティック検索や類似度検索に利用できます。
  OpenAI や外部ライブラリで生成した埋め込みをセンサーデータと一緒に保存し、異常検知に応用できます。
* **グラフストレージ** – センサー間の関係（トポロジや依存関係）を表現する必要がある場合、**PostgreSQL + Apache AGE** によるグラフデータベースを検討します。
  経路探索やネットワーク分析が可能になります。
* **データベース内機械学習** – **Azure Database for PostgreSQL** に追加できる `azure_ai` や `pgvector` 拡張機能を使用すると、データベース内で OpenAI モデルを呼び出したりベクトル計算を行えます。
  これは Agentic Shop のワークショップで紹介されており、このラボの Change Feed 分析と同様にイベントストリームとサーバーレスコンピュートを組み合わせています。

セキュリティと可観測性を強化しつつ、こうした高度な機能を組み合わせることで、本ラボをより包括的なインテリジェントデータ処理基盤へ発展させることができます。
