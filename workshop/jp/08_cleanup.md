# 8. クリーンアップとまとめ

## Azure リソースの削除

ラボが終了したら、作成したリソースを削除して課金を防ぎましょう。
**Azure Developer CLI** の `down` サブコマンドを使用すると簡単に
後片付けができます。

```bash
azd down
```

このコマンドはプロビジョニング時に作成されたリソースグループと
関連リソース (Cosmos DB アカウント、Container Apps、Container
Registry など) を削除します。Azure ポータルからリソースグループを
削除することも可能です (`az group delete --name <リソースグループ>`)。

## 高度なクリーンアップとガバナンス

実際の環境では単にリソースグループを削除するだけでなく、ガバナンスやセキュリティを考慮したクリーンアップが求められます。

* **タグ付けとコスト管理** – Bicep テンプレート内で `Project=CosmosChangeFeed` や `Owner=<あなたの名前>` などのタグを設定し、Azure Cost Management で費用を追跡します。予算アラートを設定して、月間コストが閾値を超える際に通知を受け取りましょう。
* **リソースロックとポリシー** – 重要なリソース（Cosmos DB アカウントなど）には `ReadOnly` や `Delete` ロックを設定して、誤って削除されることを防ぎます。Azure Policy を利用して命名規則や TLS 強制、許可する SKU を定義し、組織内のコンプライアンスを維持します。
* **ソフトデリートとバックアップ** – Cosmos DB の **連続バックアップ** 機能を有効にすると、誤って削除したデータを一定期間復旧できます。Container Apps や ACR でもイメージのバージョン履歴や保持ポリシーを設定して、ローリングバックが可能になるよう準備しておきます。
* **自動クリーンアップスクリプト** – PowerShell や Bash、azd フックを使って定期的に開発用リソースを削除するスクリプトを用意すると、予期せぬコスト発生を防止できます。例えば、夜間に開発環境を停止するスケジュールタスクを設定します。

## まとめ

このハンズオンラボでは、次のことを学びました:

* **Azure Cosmos DB Change Feed** を利用して、コンテナ全体を
  スキャンすることなく増分データを処理する方法。
* ランダムな間隔で IoT データを生成する **ジェネレーター** の
  実装方法。
* Change Feed からデータを読み取り、各センサーの直近 10 件の記録から
  最大値・最小値・平均値を計算して保存する **サマライザー** の構築。
* 集計データを問い合わせ、ブラウザで応答的なグラフとして表示する
  **ビジュアライザー** の開発。
* **Bicep** テンプレートと **Azure Developer CLI** を使った
  インフラのプロビジョニングとアプリのデプロイ。

今後は、イベントソーシングやマテリアライズドビューの作成、
マルチリージョン複製など、Change Feed を活用したより高度なパターン
にも挑戦してみてください。ぜひコードベースを拡張して、自分だけの
センサーや分析、可視化ツールを追加してみましょう。

## 次のステップと学習リソース

このラボの応用例として、次のようなトピックに取り組んでみてください。

* **サーバーレス PostgreSQL と AI** – Agentic Shop のワークショップでは、PostgreSQL でベクトル検索や OpenAI モデルを呼び出す多エージェントオーケストレーターを構築しています【468256300685384†L3-L49】。Cosmos DB の Change Feed と組み合わせることで、トランザクション処理と分析処理をハイブリッドに実行できます。
* **Power BI によるリアルタイムダッシュボード** – Cosmos DB の直接クエリコネクタや、Change Feed を Synapse Analytics に取り込んでビジュアルなレポートを作成します。
* **Event Grid と Durable Functions** – Change Feed を Event Grid に接続し、Durable Functions で複雑なワークフローやサガパターンを実装します。
* **カオスエンジニアリング** – Cosmos DB のフェイルオーバーやネットワーク遅延、コンテナのクラッシュなどを意図的に発生させ、リトライロジックやスケーリング挙動を検証します。

こうした学習を進めることで、エンタープライズ要件を満たす堅牢で拡張性の高いアーキテクチャへと発展させることができます。
